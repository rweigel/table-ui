<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
    <title></title>
    <link rel="icon" href="img/favicon.svg">
    <link href="//cdn.datatables.net/v/dt/jq-3.6.0/dt-1.13.4/af-2.5.3/cr-1.6.2/fc-4.2.2/fh-3.3.2/r-2.4.1/datatables.min.css" rel="stylesheet"/>
    <script src="//cdn.datatables.net/v/dt/jq-3.6.0/dt-1.13.4/af-2.5.3/cr-1.6.2/fc-4.2.2/fh-3.3.2/r-2.4.1/datatables.min.js"></script>
    <script src="//cdn.datatables.net/plug-ins/1.13.4/dataRender/ellipsis.js"></script>
    <script src="render.js"></script>
    <style>
    body {
      margin: 1em;
      margin-top: 0.5em;
    }
    /*th, td { white-space: nowrap; }*/

    h1 {
      font-size: 1em;
    }
    button {
      background-color: white;
      border: 1px solid black;
    }
    select.columnUniques {
      visibility: hidden;
      overflow: auto;
      margin-top: 0.25em;
    }

    /*
      Fix for Chrome autofill, which has its own background color.
      When an autofill value is selected, the input gets a class of
      input:-webkit-autofill.
    */
    input:-webkit-autofill,
    input:-webkit-autofill:hover,
    input:-webkit-autofill:focus {
      -webkit-text-fill-color: black;
      -webkit-box-shadow: 0 0 0px 40rem yellow inset;
    }

    #table1 {
      width: 100%;
      padding-top: 1em;
    }
    #table1_filter {
      float: left;
      display: none;
    }
    summary {
      cursor: pointer;
    }
    details code {
      font-size: small;
      background-color: rgb(244, 244, 244);
      border: 1px solid black;
      border-radius: 4px;
      padding: 0.1em;
    }

    #error {
      color: red;
      font-weight: bold;
      padding: 0.5em;
      display: none;
    }
    #showHideColumns {
      margin-right: 1em;
      padding-bottom: 0.5em;
    }
    #clearAllSearches button {
      margin-right: 1em;
      background-color: yellow;
    }
    .clearOneSearch {
      white-space: nowrap;
      visibility: hidden;
      cursor: pointer;
    }

    .dataTables_wrapper .dataTables_paginate .paginate_button {
      padding: 0em;
    }

    table.dataTable thead th {
      font-size: 0.8em;
    }
    tfoot {
      display: table-header-group;
    }
    tfoot input {
      width: 100%;
      padding: 3px;
      box-sizing: border-box;
    }
    table tbody {
      font-family: monospace;
      font-size: 10pt;
    }
    .dataTables_length {
      display: inline-block;
      margin-right: 1em;
    }
    .dataTables_wrapper .dataTables_info {
      clear: none;
      padding-top: 0.45em;
      padding-left: 0.5em;
    }
    .dataTables_wrapper .dataTables_paginate {
      float: left;
      text-align: right;
    }
    .dataTables_wrapper .dataTables_paginate .ellipsis {
      padding: 0em;
    }

    table.dataTable td {
      text-align: center;
    }
    table.dataTable thead th {
      text-align: center;
    }
    table.dataTable tfoot tr th p {
      margin: 1px;
    }
    table.dataTable tfoot th, table.dataTable tfoot td {
      padding: 1px;
    }

    /* Move processing indicator to top of page */
    div.dataTables_processing {
      z-index: 101;
      top: 0px;
    }

    /*
    /* Scrollbar styling */
    /* https://simurai.com/blog/2011/07/26/webkit-scrollbar */
    .dataTables_scrollBody::-webkit-scrollbar {
      -webkit-appearance: none;
      height: 10px;
      width: 1px;
    }
    .dataTables_scrollBody::-webkit-scrollbar-thumb {
      border-radius: 10px;
      background-color: rgba(0,0,0,.5);
      box-shadow: 0 0 1px rgba(255,255,255,.5);
    }

    /* https://stackoverflow.com/a/63507769 */
    /* See also 
    /* https://datatables.net/forums/discussion/72111/how-can-i-make-the-x-scroller-fixed-sticky*/
    /* For options that may be better for when the header is stick */
    #table1 {
      transform: rotateX(180deg);
      overflow-x: auto;
    }
    .dataTables_scrollBody {
      transform: rotateX(180deg);
    }

  </style>
</head>

<body>

  <details style="background-color: white; float:right">
    <summary>Documentation</summary>
    <h1>Table Description</h1>
    <div id="tableMetadata"></div>
    <h1>Usage</h1>
    <ul>
      <li>To execute any search, press enter key after entering text in
          column text entry area.</li>
      <li>Shift+click on sort arrows
          (<span style="font-size:small;opacity:0.25">▼</span>
          or <span style="font-size:small;opacity:0.25">▲</span>) 
          to sort on multiple columns.</li>
      <li>A entry of <code>⎵</code> means value is a single blank space.</li>
      <li>To show only certain columns, enter, e.g., <code>_cols=a,b,c</code> 
          and reload page to apply changes.</li>
    </ul>
    <h1>Search</h1>
    <ul>
      <li>A search string <code>abc</code> on a column results in an SQL 
          <code>LIKE = '%abc%'</code> query. See 
          <a href="https://www.w3schools.com/sql/sql_like.asp" target="_blank">
            SQL LIKE
          </a>
          for more information on the SQL <code>LIKE</code> operator.</li>
      <li>However, if search string starts and/or ends with <code>%</code>,
          the percentage wildcards are not added automatically.</li>
      <li>Escape <code>%</code> and <code>_</code> using <code>\</code>. 
          Escape <code>\</code> with <code>\\</code>.</li>
      <li>For an exact match search for <code>abc</code>, use single quotes: 
          <code>'abc'</code>.</li>
      <li>Escape single quotes by repeating, e.g., 
          <code>'''single quoted string'''</code>.</li>
      <li>All table entries are strings.</li>
    </ul>
    <p>
      <a href="https://github.com/rweigel/table-ui" title="https://github.com/rweigel/table-ui" style="text-decoration:none" target="_blank">
        <img src="css/github-mark.svg" alt="GitHub logo" height="24px">
      </a>
    </p>
  </details>

  <div id="controls" style="padding-bottom:3px">
    <div id="error"></div>
    <span id="relatedTables" style="float:left;display:none">
      <select id="relatedTablesSelect" style="margin-right:1em;">
        <option value="">- Related Tables -</option></select>
    </span>
    <span id="showHideColumns">
      <!--These must be one line to avoid newlines in button text-->
      <span title="show/hide columns with no content"><input type="checkbox" id="hideEmptyColumns"><label for="hideEmptyColumns">Hide Empty Columns</label></span>
    </span>
    <span id="clearAllSearches" style="display:none" title="Clear all searches"><button onclick="clearAllSearches('#table1')">Clear</button></span>
  </div>

  <span id="query"> <a href="" target="_blank">Query</a></span>

  <table id="table1" class="display" style="width:100%"></table>

  <script>
    console.log("Document ready. Calling init()")
    $(document).ready(() =>init());

    async function init() {

      const tableID = '#table1';
      if (DataTable.isDataTable(tableID)) {
        console.log(`init() => isDataTable('${tableID}') is true. Destroying existing table before re-creating it.`)
        const state = $(tableID).DataTable().state();
        console.log("init() => Current DataTable state:", state);
        const table = $(tableID).DataTable();
        destroy(tableID);
      }

      const config = await getConfig();
      checkQueryString(config);

      createRelatedTables(config);

      const renderTableMetadata = window.renderTableMetadata ? window.renderTableMetadata : null;
      const tableMetadata = renderTableMetadata ? renderTableMetadata(config) : "";
      $('#tableMetadata').html(tableMetadata);

      // Add header names to table. Two rows are added.
      // The first row is for name and sorting, second row is for filtering.
      // Need to add before table is created so it is included in DataTables
      // column width calculations.
      $('#table1').append('<thead><tr></tr><tr></tr></thead>');
      let tr0 = $('#table1 > thead > tr:eq(0)');
      for (let i = 0; i < config.columns.length; i++) {
        tr0.append(`<th></th>`);
      }
      let tr1 = $('#table1 > thead > tr:eq(1)');
      for (let i = 0; i < config.columns.length; i++) {
        tr1.append(`<th>${config.columns[i]['name']}</th>`);
      }

      // https://datatables.net/reference/option/
      const dataTableOptions =
        {
          ...config,
          "stateSave": true,
          "stateSaveCallBack": function(settings, data) {
            alert('stateSaveCallBack called.');
          },
          "stateLoadParams": function(settings, data) {
            // displayStart and pageLength in top-level config above are ignored if
            // stateSave is true because saved state has precedence over this setting.
            // Setting the state above is needed because after init()
            // is called a second time, stateLoadParams is not triggered.
            // destroy() must delete state because its column visibility
            // will be used instead of the new column visibility.
            console.log("stateLoadParams() called. Deleting start, length, and columns from saved state data:") 
            console.log(data)
            delete data.start
            delete data.length
            delete data.columns
          },
          headerCallback: function(thead, data, start, end, display) {
            // This is needed to prevent DataTables from removing
            // the second header row that contains the column names.
            // It does not appear to be documented.
            //alert('here')
            return thead;
          },
          "initComplete": dtInitComplete,
        };

      console.log("init() => Calling DataTable() with options:")
      // dataTableOptions copy is needed b/c DataTable() modifies it
      // and console.log() shows the modified version.
      console.log(JSON.parse(JSON.stringify(dataTableOptions)));
      let table = $('#table1').DataTable(dataTableOptions);
      console.log("DataTable() returned:")
      console.log(table);
    }

    function dtInitComplete() {

      console.log("dtInitComplete() => DOM is ready.")

      const tableID = '#table1';

      stickyHeaderFixes(tableID, 101);

      const table = $(tableID).dataTable();
      if (getQueryValue('_cols_show') === 'nonempty') {
        msg = "dtInitComplete() => Setting hideEmptyColumns ";
        console.log(`${msg}checkbox to checked because _cols_show=nonempty in query string.`)
        $('#hideEmptyColumns').prop('checked', true);
        console.log("dtInitComplete() => Hiding empty columns.")
        let columnEmpty = emptyColumns(tableID, true);
        table.api().columns(columnEmpty).visible(false, false)
      } else {
        console.log("dtInitComplete() => Showing all columns.")
      }

      setEvents(tableID);

      // Must be before adjustDOM() b/c calls $(window).resize(), which triggers
      // widths of columns to be recalculated based on content added in call
      // to createColumnConstraints().
      createColumnConstraints(tableID);

      adjustDOM(tableID);

      watchForFloatingHeader();

      console.log("dtInitComplete() finished.")
    }

    async function getHeader() {
      let resp = await fetch(window.location.pathname + "header");
      const header = await resp.json();
      getHeader.header = header;
      return header;
    }

    async function getConfig() {

      const url = window.location.pathname + "config"
      console.log("getConfig() => Getting config from " + url)
      let resp = await fetch(url);
      const config = await resp.json();

      const tableName = $('title').text(config.tableUI.tableMetadata.name);

      // Update entries in config.columns as needed.
      _columns(config);

      // Update config['pageLength'] and config['lengthMenu'] as needed.
      _pageLength(config);

      let page0based = (-1 + parseInt(getQueryValue('_page', 1)))
      config['displayStart'] = config['pageLength'] * page0based;

      config['ajax'] = window.location.pathname + "data/";

      if (config['serverSide']) {
        config['ajax'] = {
          "url": window.location.pathname + "data/",
          "type": "get",
          "data": _ajaxData,
          "error": _ajaxError
        };
      }
      console.log("getConfig() => Setting getConfig.config = config.")
      getConfig.config = config;

      console.log("getConfig() => Returning config:")
      console.log(config)

      return config;

      function _pageLength(config) {
        // Update pageLength and lengthMenu if needed.
        if (!config['pageLength']) {
          config['pageLength'] = 25;
          console.log("_pageLength() => No config['pageLength']. Setting default pageLength to 25");
          try {
            config['pageLength'] = config['lengthMenu'][0][0]
            console.log(`_pageLength() => config['lengthMenu'][0][0] found. Modifying default pageLength to be first entry in config['lengthMenu']: ${config['pageLength']}`);
          } catch(e) {
            console.log("_pageLength() => config['lengthMenu'][0][0] not found. Could not get modified default pageLength from config['lengthMenu']. Using 25.")
          }
        }
        let pageLength = config['pageLength'];
        if (getQueryValue('_length')) {
          console.log(`_pageLength() => _length query value found. Modifying default pageLength to be _length: ${getQueryValue('_length')}`);
          pageLength = parseInt(getQueryValue('_length'));
        }
        config['pageLength'] = pageLength;

        if (config['lengthMenu']) {
          try {
            console.log(`_pageLength() => Attempting to updated config['lengthMenu'] to include pageLength = ${pageLength}, if not already present.`);
            const menuVals = config['lengthMenu'][0];
            const menuNames = config['lengthMenu'][1];
            if (!menuVals.includes(pageLength)) {
              menuVals.push(pageLength);
              menuNames.push(pageLength);
              console.log(`_pageLength() => Updated config['lengthMenu'] to include pageLength = ${pageLength}`);
              config['lengthMenu'][0] = menuVals;
              config['lengthMenu'][1] = menuNames;
            } else {
              console.log(`_pageLength() => config['lengthMenu'] already includes pageLength = ${pageLength}. No change made to config['lengthMenu'].`);
            }
          } catch(e) {
            console.log(`_pageLength() => Problem with config['lengthMenu']. Setting it to [[${pageLength}, -1], [${pageLength}, 'All']].`);
            config['lengthMenu'] = [[pageLength, -1], [pageLength, "All"]];
          }
        } else {
          console.log(`_pageLength() => No config['lengthMenu']. Setting it to [[${pageLength}, -1], [${pageLength}, 'All']].`);
          config['lengthMenu'] = [[pageLength, -1], [pageLength, "All"]];
        }

        // Sort lengthMenu[0] and lengthMenu[1] by lengthMenu[0] values but keep
        // the correspondence between values and names.
        if (config['lengthMenu']) {
          console.log(`_pageLength() => Sorting config['lengthMenu'] by values in config['lengthMenu'][0].`);
          let vals = config['lengthMenu'][0];
          let names = config['lengthMenu'][1];
          // Create array of [val, name], sort by val, then split back
          let pairs = vals.map((v, i) => [v, names[i]]);
          pairs.sort((a, b) => a[0] - b[0]);
          config['lengthMenu'][0] = pairs.map(p => p[0]);
          config['lengthMenu'][1] = pairs.map(p => p[1]);

          // If -1 is in lengthMenu[0], put it at the end of the list.
          const minusOneIndex = vals.indexOf(-1);
          if (minusOneIndex !== -1 && minusOneIndex !== vals.length - 1) {
            // Remove -1 and its name
            const [minusOneVal] = vals.splice(minusOneIndex, 1);
            const [minusOneName] = names.splice(minusOneIndex, 1);
            // Push to end
            vals.push(minusOneVal);
            names.push(minusOneName);
          }
          config['lengthMenu'][0] = vals;
          config['lengthMenu'][1] = names;
        }
      }

      function _columns(config) {
        console.log("_columns() => Creating config['columns']")

        let _cols = getQueryValue('_cols');
        console.log("_columns() => _cols from query string:", _cols)
        let allVisible = true;
        if (_cols) {
          allVisible = false;
        } else {
          _cols = [];
        }

        let renderColumnFunction = window.renderColumn ? window.renderColumn : null;
        const qs = parseQueryString();
        config['searchCols'] = [];
        let columns = config['columns'];
        for (let i = 0; i < columns.length; i++) {

          columns[i]['title'] = columns[i]['title'] || columns[i]['name'];
          // Needed for _verbose server response?
          //columns[i]['data'] = columns[i]['data'] || columns[i]['name'];
          columns[i]["target"] = columns[i]["target"] || i;

          let visible = allVisible || _cols.includes(columnNames[i])
          if ([null, undefined].includes(columns[i]["visible"])) {
            columns[i]["visible"] = visible;
          }

          // Set initial search values from query string
          if (columns[i]['name'] in qs) {
            config['searchCols'].push({'search': qs[columns[i]['name']]})
          } else {
            config['searchCols'].push(null);
          }

          // ellipsis.js plug-in
          // config['columns'][i]['render'] = DataTable.render.ellipsis( 10 )

          if (renderColumnFunction) {
            const render = renderColumnFunction(columns[i]['name'], config)
            if (render) {
              columns[i]['render'] = render
            }
          }
        }
      }

      function _ajaxData(dtp) {
        console.log("_ajaxData() => Preparing query parameters for AJAX search using dtp object:");
        console.log(JSON.parse(JSON.stringify(dtp)));

        $("#error").hide();

        if (dtp.search.value) {
          dtp._globalsearch = dtp.search.value;
        }

        _orders = [];
        for (let i = 0; i < dtp.order.length; i++) {
          let c = dtp.order[i].column;
          let name = dtp.columns[c]['name'];
          _orders.push(dtp.order[i]['dir'] == 'asc' ? name : '-' + name);
        }
        dtp._orders = _orders.join(",");

        dtp._length = dtp.length;
        dtp._start = dtp.start;
        dtp._draw = dtp.draw;

        console.log(`_ajaxData() => Deleting non server API keys from dtp object.`)
        for (const key in dtp) {
          if (!key.startsWith('_')) {
            delete dtp[key];
          }
        }

        const config = getConfig.config;
        const columnObject = array2object(config.columns, 'name');
        let qs = parseQueryString();
        for (const [key, val] of Object.entries(qs)) {
          if (!(key in dtp) && (key in columnObject)) {
            console.log(`_ajaxData() => Adding ${key} = '${val}' from query string to dtp object.`);
            dtp[key] = val;
          }
        }

        console.log("_ajaxData() => Returning updated dtp object:")
        console.log(dtp);

        console.log("_ajaxData() => Setting query link in DOM.")
        let url = window.location.pathname + "data/" + "?";
        url += new URLSearchParams(dtp).toString()
        $('#query > a').attr('href', url);
        $('#query').show();

        return dtp;
      }

      function _ajaxError(xhr, error, thrown) {
        console.error("AJAX error");
        console.error("xhr: ", xhr);
        console.error("error: ", error);
        console.error("thrown: ", thrown);
        let emsgo = "An error occurred while loading data";
        if (xhr) {
          let stat = xhr.status || ''
          let text = xhr.statusText || ''
          emsg =  `${emsgo}. Status: '${stat}' | Status text: '${text}'.`;
          if (xhr.responseURL) {
            emsg = `${emsgo} from ${xhr.responseURL}. ${emsg}.`;
          }
        }
        if (thrown) {
          emsg += " Thrown error: " + thrown + ".";
        }
        try {
          let resp = JSON.parse(xhr.responseText);
          if ('error' in resp) {
            emsg += ` Server response error message: ${resp['error']}.`;
          }
        } catch(e) {
          console.error("Could not parse xhr.responseText as JSON.");
          console.error(e);
        }
        $('#table1_processing').hide();
        $('#error').html(emsg + ". See console for details.").show();
      }
    }

    function createRelatedTables(config) {
      let relatedTables = config.tableUI.relatedTables ? config.tableUI.relatedTables : null;
      if (relatedTables && Array.isArray(relatedTables) && relatedTables.length > 0) {
        let options = [];
        for (rt of relatedTables) {
          options.push(`<option value="${rt.path}">${rt.name}</option>`);
        }
        $("#relatedTablesSelect").append(options).prop('selectedIndex', 1);
        $("#relatedTables").show();
        $("#relatedTablesSelect").on("change", function() {
          const url = $(this).val();
          if (url) window.location.href = url;
        });
      }
    }

    function createColumnConstraints(tableID, which) {
      let msg = "createColumnConstraints() => Setting search inputs with initial"
      console.log(`${msg} search values and setting search event.`)

      let parent = `${tableID}_wrapper`;
      if ($('.dtfh-floatingparent').length > 0) {
        let msg = "createColumnConstraints() => Floating header detected. "
        console.log(`${msg}Adding column constraints to floating header.`);
        parent = '.dtfh-floatingparent';
      }
      if (!which) which = 'all';
      const table = $(tableID).dataTable();
      const qs = parseQueryString();
      let config = getConfig.config;
      visibleIndex = 0;
      table.api().columns(':visible').every(function () {
        let column = this;
        let index = column.index();
        let name = config.columns[index]['name'];
        if (which === 'all' || which == 'input') {
          let searchOnKeypress = false == config.columns[index]['return'];
          let input = createColumnInput(parent, visibleIndex, name, column, searchOnKeypress);
        }
        if (which === 'all' || which == 'select') {
          //if (config['serverSide'] && (name === 'datasetID' || name === 'VariableName')) {
          if (config['serverSide']) {
            createColumnSelector(parent, visibleIndex, name, column);
          }
        }
        visibleIndex++;
      });
    }

    function createColumnInput(parent, visibleIndex, name, column, searchOnKeypress) {
      // Create `input` element
      let element = `thead tr:eq(0) > th`
      let th = $(`${parent} ${element}`).eq(visibleIndex).empty();
      let attrs = `class="columnSearch" name="${name}"`;
      attrs += ` style=""`;
      let input = $(`<input ${attrs} type="text" placeholder="Search col."/>`);
      const qsName = getQueryValue(name);

      let title = 'Enter search text and enter to search. ';
      title += 'See documentation for search syntax.'

      //console.log($(`${parent} thead tr:eq(0) > th`).eq(visibleIndex).outerWidth());
      let val = qsName || '';
      input
        .val(val)
        .attr('title','Enter search string and press enter to search')
        .appendTo(th)
        .off("keydown")
        .on("keydown", function() {
          if (searchOnKeypress) {
            // Do search on each keypress
            column.search($(this).val()).draw('page');
          } else {
            let keycode = (event.keyCode ? event.keyCode : event.which);
            if (keycode == '13') {
              if (th.find('select.columnUniques').length > 0) {
                let select = th.find('select.columnUniques');
                if (select.find('option').length > 0) {
                  select.prop('selectedIndex', 0);
                }
              }
              column.search($(this).val()).draw('page');
            }
          }
        })
        .attr('title', title)
        .off('input')
        .on('input', function() {
          if ($(this).val()) {
            clearBtn.css('visibility', 'visible');
          } else {
            clearBtn.css('visibility', 'hidden');
          }
        })
        .wrap('<div style="white-space: nowrap;"></div>');

      let clearBtn = $(`<span class="clearOneSearch">✘</span>`);
      clearBtn.appendTo($(input.parent()));
      clearBtn.on('mousedown', function(e) {
          e.preventDefault();
          input.val('');
          clearBtn.css('visibility', 'hidden');
          input.focus();
          column.search('').draw('page');
        });

      if (val) {
        input.css('background-color', 'yellow');
        clearBtn.css('visibility', 'visible');
        $('#clearAllSearches').show();
      }

    }

    function createColumnSelector(parent, visibleIndex, name, column) {

      if (!createColumnSelector.cache) {
        createColumnSelector.cache = {};
      }

      let th = $(`${parent} thead tr:eq(0) > th`).eq(visibleIndex)

      let selectOld = th.find('select.columnUniques');
      selectOld.remove();

      const input = th.find('input.columnSearch');

      const maxLen = 100;
      const width = input.innerWidth()
      const title = `Most frequent unique values and (count); max of ${maxLen} shown`;
      const attrs = `class="columnUniques" title="${title}" name="${name}"`
      const dw = 4;
      select = $(`<select ${attrs} style="width: ${width+dw}px;"></select>`);
      select.appendTo(th);

      // Calculate the offset needed to align with input.columnSearch
      const inputOffset = input.offset().left;
      const selectOffset = select.offset().left;
      const offsetDifference = inputOffset - selectOffset;
      // Why is -dw here and +dw in select width above needed for alignment?
      select.css('margin-left', `${offsetDifference-dw}px`);

      const qs = parseQueryString();
      let searches = {};
      for (const [key, val] of Object.entries(qs)) {
        if (!key.startsWith('_')) {
          searches[key] = val;
        }
      }

      searches = new URLSearchParams(searches).toString();
      let url = `data/?${searches}&_return=${encodeURIComponent(name)}&_uniques=true&_length=100`

      getOptionHTML(url, setOptionHTML)

      function setOptionHTML(html) {
        if (!html) {
          select.remove();
          return;
        }
        if ($(parent).length === 0) {
          // Parent has been removed from DOM, so do not add select.
          return;
        }
        select = th.find(`select[name="${name}"]`);
        select.append(html);
        if (qs[name]) {
          select.val(qs[name].replace(/^'/,'').replace(/'$/,''));
        }
        createColumnSelector.cache[url] = select.html();
        select.css('visibility', 'visible');
        setChangeEvent(select);
      }

      function getOptionHTML(url, cb) {
        if (createColumnSelector.cache[url]) {
          //console.log("createColumnSelector() => Using cached HTML for select options.")
          cb(createColumnSelector.cache[url]);
          return;
        }
        // Fetch unique values for this column
        $.ajax({
          url: url,
          method: "GET",
          dataType: "json",
          success: function (data) {
            if (!data[name]) {
              cb(null);
              return;
            }
            let html = `<option value="" selected></option>`;
            data[name].forEach(function (val) {
              html += `<option value="${val[0]}">${val[0]} (${val[1]})</option>`;
            });
            cb(html);
          }
        });
      }

      function setChangeEvent(select) {
        // On select change, update input and trigger search
        select.off("change").on("change", function () {
          console.log("createColumnSelector => select change event triggered.")
          let val = $(this).val().replace(/'/g, "''");
          if (val === "") {
            console.log("createColumnSelector => Setting input to empty string.")
            input.val("");
            select.parent().find('span.clearOneSearch').css('visibility', 'hidden');
          } else {
            val = `'${val}'`;
            console.log(`createColumnSelector => Setting input to ${val}.`)
            input.val(val);
            select.parent().find('span.clearOneSearch').css('visibility', 'visible');
          }
          console.log("createColumnSelector => Triggering search and draw('page').")
          column.search($(this).val()).draw('page');
        });
      }
  }

    function watchForFloatingHeader() {
      if (!watchForFloatingHeader.enabled) {
        watchForFloatingHeader.enabled = true;
      } else {
        return;
      }
      let msg = "watchForFloatingHeader() => Setting up MutationObserver ";
      console.log(`${msg}to watch for addition of dtfh-floatingparent element.`);
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach(function(node) {
              if ($(node).hasClass('dtfh-floatingparent')) { 
                msg = "watchForFloatingHeader() => dtfh-floatingparent ";
                console.log(`${msg}was added.`);
                stickyHeaderFixes(1);
                setTimeout(() => {createColumnConstraints('#table1')}, 1);
              }
            });
          }
        });
      });
      const config = { childList: true, subtree: true }; // Observe child additions and in subtrees
      observer.observe(document.body, config); // Start observing from the body
    }

    function setEvents(tableID) {

      removeEventListener("input", (event) => {
        console.log('Removing input event:', event);
      });
      addEventListener("input", (event) => {
        if (event.target && event.target.className === 'columnSearch') {
          console.log('setEvents() => input event. Autocomplete selection event on columnSearch input. Showing clearAllSearches button.')
          $('#clearAllSearches').show();
          return;
          let backgroundColor = $(event.target).css('background-color')
          console.log(backgroundColor !== 'rgb(255, 255, 0)')
          if (backgroundColor !== 'rgb(255, 255, 0)') {
            console.log('setEvents() input event. => Setting background color of input to yellow.')
            // This does not work. See input:-webkit-autofill in CSS for fix. 
            //$(event.target).css('background-color', 'yellow');
          }
        }
      });

      console.log('setEvents() => Setting search.dt.')
      $(tableID).off('search.dt').off('search.dt');
      $(tableID).on('search.dt', function (event) {
        console.log('setEvents() => search.dt triggered')
        updateQueryString('_page', null);
        $("#table1").DataTable().page(0);
        setQueryStringFromSearch()
      })

      $(tableID).on('stateSaveParams.dt', function (e, settings, data) {})

      console.log('setEvents() => Setting page.dt.')
      let pageChanged = false;
      $(tableID).off('page.dt').on('page.dt', function () {
        console.log('setEvents() => page.dt triggered')
        const info = $(tableID).DataTable().page.info();
        $('#pageInfo').html('Showing page: ' + info.page + ' of ' + info.pages);
        if (info.page > 0) {
          updateQueryString('_page', info.page + 1);
        } else {
          updateQueryString('_page', null);
        }
        pageChanged = true;
      });

      console.log('setEvents() => Setting length.dt.')
      let lengthChanged = false;
      $(tableID).off('length.dt').on('length.dt', function (e, settings, len) {
        console.log('setEvents() => length.dt triggered')
        updateQueryString('_length', len);
        lengthChanged = true;
      })

      console.log('setEvents() => Setting preDraw.dt.')
      $(tableID).off('preDraw.dt').on('preDraw.dt', function () {
        console.log('setEvents() => preDraw.dt triggered')
      })

      console.log('setEvents() => Setting draw.dt and triggering it.')
      _emptyColumns = emptyColumns(tableID);
      $(tableID)
        .off('draw.dt')
        .on('draw.dt', function () {
          console.log('setEvents() => draw.dt triggered.')

          console.log("setEvents() => draw.dt => Calling adjustDOM()")
          adjustDOM(tableID);

          if (pageChanged && getQueryValue('_cols_show') === 'nonempty') {
            let msg = 'setEvents() => draw.dt => ';
            console.log(`${msg}Page was changed and _cols_show=nonempty. Checking for change in empty columns.`)
            pageChanged = false;
            _emptyColumnsNow = emptyColumns(tableID);
            if (_emptyColumns.length === _emptyColumnsNow.length) {
              console.log(`${msg} Number of empty columns has not changed. Not updating column visibility.`)
              return;
            }
            console.log(`${msg} Number of empty columns has changed. Calling init().`)
            _emptyColumns = _emptyColumnsNow;
            init()
          }
        })

      console.log("setEvents() => Setting click event for hideEmptyColumns checkbox.")
      $('#hideEmptyColumns').unbind('click');
      $('#hideEmptyColumns').click(function() {
        const table = $(tableID).dataTable();
        if ($(this).is(':checked')) {
          console.log("setEvents() => #hideEmptyColumns clicked to checked.")
          updateQueryString('_cols_show', 'nonempty');
          init();
        } else {
          console.log("setEvents() => #hideEmptyColumns clicked to unchecked.")
          updateQueryString('_cols_show', null);
          init()
        }
      });
    }

    function stickyHeaderFixes(index) {
      if (!index) {
        index = 10;
      }
      let parent = "#table1_wrapper div.dataTables_scrollHead";
      // Address a bug in DataTables v1 where duplicate header
      // cells appear temporarily during transition to sticky header.
      $(`${parent} thead tr:eq(0) > th:eq(0)`)
        .css('position', 'sticky')
        .css('left', '0px')
        .css('z-index', index)
        .css('background-color', 'white');
      $(`${parent} thead tr:eq(1) > th:eq(0)`)
        .css('position', 'sticky')
        .css('left', '0px')
        .css('z-index', index)
        .css('background-color', 'white');
    }

    function adjustDOM(tableID) {

      console.log("adjustDOM() => called.")
      const table_info = `${tableID}_info`;
      const table_length = `${tableID}_length`;
      const table_filter = `${tableID}_filter`;
      const table_paginate = `${tableID}_paginate`;

      console.log("adjustDOM() => Moving global search input.")
      let input = $(`${table_filter} input`).attr('placeholder','Global search')
      $(`${table_filter} label`).replaceWith(input[0]);
      $(`${table_info}`).insertAfter(table_filter);

      console.log("adjustDOM() => Moving global search input.")
      let numCols = $(tableID).DataTable().columns().nodes().length;
      let numColsVisible = $(tableID).DataTable().columns(':visible').nodes().length;
      let colInfo = ` and all ${numCols} columns`;
      if (numCols !== numColsVisible) {
        colInfo = ` and ${numColsVisible} of ${numCols} columns`;
      }

      console.log("adjustDOM() => Creating 'Showing ...' string.")
      const info = $(tableID).DataTable().page.info();
      const nRows = info.recordsDisplay.toLocaleString('en-US')
      let txt = `Showing ${parseInt(info.start)+1}-${parseInt(info.end)} of ${nRows} rows`
      if (info.recordsDisplay === 0) {
        txt = `Showing 0 rows`
      }
      if (info.recordsTotal != info.recordsDisplay) {
        const recordsTotal = info.recordsTotal.toLocaleString('en-US')
        txt += ` (filtered from ${recordsTotal} total)`
      }
      txt += `${colInfo}.`
      $(table_info).text(txt);

      console.log("adjustDOM() => Moving pagination controls and hiding if only one page.")
      $(table_paginate).insertAfter(table_filter);
      // Hide paging if only one page.
      if ($(tableID).dataTable().api().page.info().pages === 1) {
        console.log("setEvents() => draw.dt => Hiding pagination b/c only one page.")
        $(table_paginate).hide();
      } else {
        console.log("setEvents() => draw.dt => Showing pagination b/c multiple pages.")
        $(table_paginate).show();
      }

      console.log("adjustDOM() => Moving length control.")
      let select = $(`${table_length} select`)
      select.appendTo(table_length)
      $(`${table_length} label`).text('Rows per page: ')
      $('#table1_length').insertBefore('#clearAllSearches');

      console.log("adjustDOM() => Modifying Previous/Next buttons.")
      const prev = $(`${tableID}_previous`);
      prev.attr('title','Previous page');
      if (prev.length > 0) {
        const html = prev.html();
        if (html) {
          prev.html(html.replace('Previous','◀'));
        }
      }
      const next = $(`${tableID}_next`);
      next.attr('title','Next page');
      if (next.length > 0) {
        const html = next.html();
        if (html) {
          next.html(html.replace('Next','▶'));
        }
      }

      if (info.pages > 0) {
        const _page = getQueryValue("_page")
        let msg = `setEvents() => draw.dt =>  _page = ${_page}, info.pages = ${info.pages}. `
        console.log(msg)
        if (_page) {
          if (parseInt(_page) > info.pages) {
            msg += `Setting _page to ${info.pages}`
            console.log(`${msg} and drawing page ${info.pages-1}.`)
            updateQueryString('_page', info.pages);
            $(tableID).DataTable().page(info.pages-1).draw('page');
          }
        }
      }

      console.log("adjustDOM() => Moving query link.")
      $(table_info).append($("#query"));

      console.log("adjustDOM() => Setting timeout to execute $(window).resize().")
      setTimeout(function() {
        let msg = "adjustDOM() => Executing $(window).resize() to "
        msg += "trigger event that causes left column header widths"
        console.log(`${msg} to match the width of the left column body.`)
        $(window).resize()
      }, 0);

      console.log("adjustDOM() finished.")
    }

    function emptyColumns(tableID, indices) {
      let data = $(tableID).DataTable().rows({ page: 'current' }).data().toArray();
      console.log("emptyColumns() => Data for current page:")
      console.log(data)
      let columnEmpty = [];
      for (let r = 0; r < data.length; r++) {
        for (let c = 0; c < data[r].length; c++) {
          if (r == 0) {
            columnEmpty.push(true);
          }
          if (data[r][c] !== null && data[r][c] !== "") {
            columnEmpty[c] = false;
          }
        }
      }

      if (indices) {
        let columnEmpty2 = []
        for (let c = 0; c < columnEmpty.length; c++) {
          if (columnEmpty[c]) {
            columnEmpty2.push(c);
          }
        }
        console.log("Computed columnEmpty index array:")
        console.log(columnEmpty2)
        return columnEmpty2;
      }

      console.log("emptyColumns() => Computed columnEmpty array:")
      console.log(columnEmpty)

      return columnEmpty;
    }

    function destroy(tableID) {
      console.log("destroy() => Called.")

      let tableWrapper = $(tableID + "_wrapper");
      if (tableWrapper.length > 0) {
        console.log(`destroy() => Destroying table ${tableID}`)
        $('#error').empty();
        $('#tableMetadata').empty();
        $('#table1_length').remove();
        // https://datatables.net/forums/discussion/comment/190544/#Comment_190544
        $(tableID).DataTable().state.clear();
        $(tableID).DataTable().destroy();
        tableWrapper.remove();
        $(tableID).empty();
        // Remove event handlers added to table, document, and window
        $(tableID).off();
        $(document).off();
        $(window).off();
      } else {
        console.log(`destroy() => No table ${tableID} to destroy.`)
      }
    }

    function clearAllSearches(tableID) {
      let qs = parseQueryString();
      for (const key in qs) {
        if (!key.startsWith('_')) {
          delete qs[key];
        }
      }
      location.hash = decodeURIComponent($.param(qs));
      init();
    }

    function parseQueryString() {
      // http://paulgueller.com/2011/04/26/parse-the-querystring-with-jquery/
      let nvpair = {};
      let qs = window.location.hash.replace('#', '');
      if (qs.length === 0) {
        return {};
      }
      let pairs = qs.split('&');
      $.each(pairs, function(i, v){
        let pair = v.split('=');
        nvpair[pair[0]] = pair[1];
      });
      return nvpair;
    }

    function getQueryValue(name, defaultValue) {
      let qs = parseQueryString();
      if (!qs[name]) {
        return defaultValue;
      }
      return qs[name];
    }

    function checkQueryString(config) {
      console.log("checkQueryString() => Checking query string for invalid column names.");

      let qs = parseQueryString();
      console.log("checkQueryString() => Query string:")
      console.log(qs);
      let columnObject = array2object(config.columns, 'name');

      console.log("checkQueryString() => what = 'keys'. Checking keys but not values in query string.");
      let alerted = false;
      for (const [key, val] of Object.entries(qs)) {
        if (key.startsWith('_')) {
          console.log(`checkQueryString() => found state parameter '${key}' in query string. Leaving it.`);
          continue;
        }
        if (key in columnObject) {
          console.log(`checkQueryString() => Found valid key = '${key}' in query string.`);
        } else {
          console.log(`checkQueryString() => Found invalid key = '${key}' in query string. Removing it.`);
          if (alerted === false) {
            alerted = true;
            alert(`Invalid column name in query string: "${key}". Removing it from query string and any other invalid column names.`);
          }
          updateQueryString(key, null);
        }
      }

      console.log("checkQueryString() => what = 'cols'. Checking only _cols parameter in query string.");
      let _cols = getQueryValue('_cols');
      if (!_cols) {
        console.log("checkQueryString() => No _cols in query string. Leaving it.")
        return;
      }

      _cols = _cols.split(',');
      let updateHash = false;
      for (let i = 0; i < _cols.length; i++) {
        let columnName = _cols[i];
        if (columnName in columnObject) {
          continue;
        } else {
          console.log(`checkQueryString() => Column name '${columnName}' not found in config.columnDefs.`);
          if (!updateHash) {
            alert(`checkQueryString() => Column name in query string not found: "${colName}". Removing it and any other invalid column names from query string.`);
          }
          updateHash = true;
          delete _cols[i];
        }
      }
      if (updateHash) {
        console.log("checkQueryString() => Updating query string to remove invalid column names.")
        _cols = columnNames.filter(Boolean); // Remove any null/undefined values
        console.log(_cols)
        updateQueryString('_cols', _cols.join(','));
      }
    }

    function setQueryStringFromSearch() {
      let msg = "setQueryStringFromSearch() => Stepping through column ";
      console.log(`${msg}search inputs.`);
      // Step through column search inputs and update query string
      // Highlight inputs with search values and remove highlight for
      // inputs with no search value.
      let searchValue;
      let inputs;
      if ($(".dtfh-floatingparent").length > 0) {
        msg = "setQueryStringFromSearch() => .dtfh-floatingparent found. ";
        console.log(`${msg}Using inputs under it.`);
        inputs = $('.dtfh-floatingparent input.columnSearch');
      } else {
        msg = "setQueryStringFromSearch() => No .dtfh-floatingparent found. ";
        console.log(`${msg}Using inputs under .dataTables_scrollHead`);
        inputs = $('.dataTables_scrollHead input.columnSearch');
      }
      msg = "setQueryStringFromSearch() => Reading ";
      console.log(`${msg}${inputs.length} column search inputs.`);
      for (let input of inputs) {
        let name = $(input).attr('name');
        searchValue = $(input).val();
        if (searchValue) {
          let msg = 'setQueryStringFromSearch() => Found search value for column'
          msg += ` '${name}'. Updating query string and highlighting input.`
          $(input).css('background-color', 'yellow');
          msg = "setQueryStringFromSearch() => Updating query string with ";
          msg += `search value for column '${name}' = '${searchValue}'.`;
          console.log(msg)
          updateQueryString(name, searchValue);
        } else {
          //console.log(`No search value for column '${name}'.`);
          $(input).css('background-color', '');
          let qs = parseQueryString();
          if (qs[name]) {
            let msg = `setQueryStringFromSearch() => Found ${name} in `
            console.log(`${msg}query string. Removing it from query string.`);
            updateQueryString(name, null);
          }
        }
        console.log("setQueryStringFromSearch() => Showing or hiding Clear button based on presence of searches in query string.")
        const qs = parseQueryString();
        const numSearchKeys = Object.keys(qs).filter(k => !k.startsWith('_')).length;
        let msg = `setQueryStringFromSearch() => There are `;
        if (numSearchKeys > 0) {
          console.log(`${msg}${numSearchKeys}search terms in the query string. Showing Clear button.`)
          $('#clearAllSearches').show();
        } else {
          console.log(`${msg}no search terms in the query string. Hiding Clear button.`)
          $('#clearAllSearches').hide();
        }

      }
    }

    function updateQueryString(name, val) {
      console.log(`updateQueryString() called with name='${name}' and val='${val}'`);
      let qs = parseQueryString();
      if (val === null) {
        console.log(`updateQueryString() => Removing ${name} from query string.`);
        delete qs[name];
      } else {
        qs[name] = val;
      }

      // Put _ parameters at end of query string
      const sortedKeys = Object.keys(qs).sort((a, b) => {
        if (a.startsWith('_')) return 1;
        return -1;
      });

      const sortedQs = {};
      for (const key of sortedKeys) {
        sortedQs[key] = qs[key];
      }
      location.hash = decodeURIComponent($.param(sortedQs));
    }

    function array2object(arr, key) {
      if (!key) {
        key = 'name';
      }
      // Create a map from column name to index
      const obj = {};
      for (let i = 0; i < arr.length; i++) {
        obj[arr[i][key]] = arr[i];
      }
      return obj;
    }

  </script>

</body>

</html>
