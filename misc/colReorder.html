<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
    <title>__TABLENAME__</title>
    <link rel="icon" href="img/favicon.svg">
    <link href="https://cdn.datatables.net/v/dt/jq-3.7.0/dt-2.3.4/cr-2.1.1/cc-1.1.0/fc-5.0.5/fh-4.0.3/rr-1.5.0/sr-1.4.2/datatables.min.css" rel="stylesheet" integrity="sha384-dgzX5TLI69CXeC13LXEjdPjDiPvUE1PZwerPcXG65BoG6lJ/8w0waUP/mE71FGO0" crossorigin="anonymous">
    <script src="https://cdn.datatables.net/v/dt/jq-3.7.0/dt-2.3.4/cr-2.1.1/cc-1.1.0/fc-5.0.5/fh-4.0.3/rr-1.5.0/sr-1.4.2/datatables.min.js" integrity="sha384-6NKnfbP0rfqUFM98vKb1/C+11u0z33ztkrtql0hAQyzk4+Zvg/TQQYRNDVqeyg1p" crossorigin="anonymous"></script>
    <script src="render.js"></script>
    <style>
    body {
      margin: 1em;
      margin-top: 0.5em;
    }
    button {
      background-color: white;
      border: 1px solid black;
    }
    #table1 {
      width:100%;
      padding-top: 1em;
    }
    #table1_filter {
      float: left;
      display: none;
    }
    summary {
      cursor: pointer;
    }
    #showHideColumns {
      margin-right: 1em;
      padding-bottom: 0.5em;
    }
    #clearAllSearches {
      margin-right: 1em;
    }
    .dataTables_wrapper .dataTables_paginate .paginate_button {
      padding: 0em;
    }

    table.dataTable thead th {
      font-size: 0.8em;
    }
    tfoot {
      display: table-header-group;
    }
    tfoot input {
      width: 100%;
      padding: 3px;
      box-sizing: border-box;
    }
    table tbody {
      font-family: monospace;
      font-size: 10pt;
    }
    .dataTables_length {
      display: inline-block;
      margin-right: 1em;
    }
    .dataTables_wrapper .dataTables_info {
      clear: none;
      padding-top: 0.45em;
      padding-left: 0.5em;
    }
    .dataTables_wrapper .dataTables_paginate {
      float: left;
      text-align: right;
  }

    table.dataTable td {
      text-align: center;
    }
    table.dataTable thead th {
      text-align: center;
    }
    table.dataTable tfoot tr th p {
      margin: 1px;
    }
    table.dataTable tfoot th, table.dataTable tfoot td {
      padding: 1px;
    }

    div.dataTables_processing {
      z-index: 101;
      top: 0px;
    }

    /* https://simurai.com/blog/2011/07/26/webkit-scrollbar */
    .dataTables_scrollBody::-webkit-scrollbar {
      -webkit-appearance: none;
      width: 1px;
    }
    .dataTables_scrollBody::-webkit-scrollbar-thumb {
      border-radius: 1px;
      background-color: rgba(0,0,0,.5);
      box-shadow: 0 0 1px rgba(255,255,255,.5);
    }
    h1 {
      font-size: 1em;
    }

    /* https://stackoverflow.com/a/63507769 */
    /*
    #table1 {
      transform: rotateX(180deg);
      overflow-x: auto;
    }
    .dataTables_scrollBody {
      transform: rotateX(180deg);
    }
    */

    </style>
</head>

<body>

  <details style="background-color: white; float:right">
    <summary>Documentation</summary>
    <h1>Table Description</h1>
    <div id="tableMetadata"></div>
    <h1>Usage</h1>
    <ul>
      <li>To execute any search, press enter key after entering text in column text entry area.</li>
      <li>Shift+click on sort arrows (<span style="font-size:small;opacity:0.25">▼</span> or <span style="font-size:small;opacity:0.25">▲</span>) to sort on multiple columns.</li>
      <li>A entry of <code>⎵</code> means value is a single blank space.</li>
      <li>To show only certain columns, enter, e.g., <code>_cols=a,b,c</code> and reload page to apply changes.</li>
      <li>To show certain columns in a particular order, enter, e.g., <code>_cols=c,b,a,...</code> and reload page. (The <code>...</code> indicates other columns should be displayed in default order.)</li>
    </ul>
    <h1>Search</h1>
    <ul>
      <li>A search string <code>abc</code> on a column results in an SQL <code>LIKE = '%abc%'</code> query.</li>
      <li>However, if search string starts and/or ends with <code>%</code>, the percentage wildcards are not added automatically.</li>
      <li>See <a href="https://www.w3schools.com/sql/sql_like.asp">SQL LIKE</a> for more information on the SQL <code>LIKE</code> operator.</li>
      <li>For an exact match search for <code>abc</code>, use single quotes: <code>'abc'</code>.</li>
      <li>All entries are stored as strings.</li>
    </ul>
  </details>

  <div id="controls" style="padding-bottom:3px">
    <span id="showHideColumns">
      <!--These must be one line to avoid newlines in button text-->
      <span title="show/hide columns with no content"><input type="checkbox" id="hideEmptyColumns"><label for="hideEmptyColumns">Hide Empty Columns</label></span>
    </span>
    <span id="clearAllSearches" style="display:none" title="Clear all searches"><button onclick="clearAllSearches('#table1')">Clear</button></span>
  </div>

  <table id="table1" class="display" style="width:100%">
  </table>

  <script>
    console.log("Document ready. Calling init()")
    $(document).ready(() =>init());

    async function init() {

      // TODO: columnEmpty is no longer used. Would it speed
      // up init() if it were used in events?

      const tableID = '#table1';
      if (DataTable.isDataTable(tableID)) {
        console.log(`isDataTable('${tableID}') is true. Destroying existing table before re-creating it.`)
        const state = $(tableID).DataTable().state();
        console.log("Current DataTable state:", state);
        const table = $(tableID).DataTable();
        destroy(tableID);
      }

      checkQueryString('values');

      const config = await getConfig();
      getConfig.config = config;

      checkQueryString('cols');

      const renderTableMetadata = window.renderTableMetadata ? window.renderTableMetadata : null;
      if (renderTableMetadata) {
        console.log("init() => renderTableMetadata() function found in render.js");
      }
      const tableMetadata = renderTableMetadata ? renderTableMetadata(config) : "";
      if (tableMetadata !== "") {
        console.log(`init() => Setting #tableMetadata HTML to that returned by renderTableMetadata(): ${tableMetadata}`);
        $('#tableMetadata').html(tableMetadata);
      }

      // https://datatables.net/reference/option/
      delete config['searchCols']
      delete config['colReorder']
      let dataTableOptions =
        {
          ...config,
          "stateSave": true,
          serverSide: true,
          columnControl: ['search'],
          ordering: {
              indicators: false,
              handler: false
          },
          "initComplete": dtInitComplete,
          "stateSaveCallBack": function(settings, data) {
            console.log('stateSaveCallBack() called.');
          },
          "stateLoadParams": function(settings, data) {
            // displayStart, pageLength, columns, colReorder in top-level config
            // above are ignored if stateSave is true and previous state for
            // tableID is found in localStorage. Here we want to not ignore
            // the top-level config values on first load because they are set by
            // hash fragment. Setting the state above instead of here is also
            // needed because after init() is called a second time, stateLoadParams
            // is not triggered.
            console.log("stateLoadParams() called. Deleting start, length, columns, and ColReorder from saved state data:") 
            console.log(data)
            return
            delete data.start
            delete data.length
            delete data.columns
            delete data.ColReorder
          },
        };
      console.log("Calling DataTable() with options:")
      // dataTableOptions copy is needed b/c DataTable() modifies it
      // and console.log() shows the modified version.
      console.log(JSON.parse(JSON.stringify(dataTableOptions)));
      let table = $('#table1').DataTable(dataTableOptions);
      console.log("DataTable() returned:")
      console.log(table);
      return
      //table.colReorder.order([0,2,1]);

    }

    function dtInitComplete() {
      console.log("dtInitComplete() called. DOM is ready.")
      const table = $("#table1").DataTable()
      setEvents('#table1');
      return

      console.log("dtInitComplete() finished.")
      $("#table1").DataTable().page(getQueryValue('_page', 1)-1).draw('page');

      let _emptyColumns = [];
      if (getQueryValue('_cols_show') === 'nonempty') {
        console.log("Setting hideEmptyColumns checkbox to checked because _cols_show=nonempty in query string.")
        $('#hideEmptyColumns').prop('checked', true);
        console.log("Getting empty columns")
        _emptyColumns = emptyColumns('#table1');
        console.log("Hiding empty columns:")
        table.columns(_emptyColumns).visible(false, false)
      } else {
        console.log("Showing all columns")
      }

      return

      // See colReorder comment above for why this needs to be done after
      // dtInitComplete is called.
      //console.log("dtInitComplete() => Reordering columns based on _cols query string parameter.");
      //$('#table1').dataTable().api().colReorder.order(columnOrder)

      console.log("Setting search inputs with initial search values and setting search event.")

      console.log("Setting column search inputs.")
      const qs = parseQueryString();
      let config = getConfig.config;
      table.api().columns(':visible').every(function () {
        let that = this;
        // Create `select` element
        let index = this.index();
        let name = config.columnDefs[index]['name'];
        console.log(name)
        console.log(`  Setting search input for column ${index} named '${name}'. Visible: ${config.columnDefs[index].visible}`);
        if (columnOrder) {
          //index = columnOrder[index];
          //name = config.columnDefs[index]['name'];
        }
        // Note that the header table does not have an id. It should.
        $("thead tr:eq(0) > th").eq(index).html('');
        let input = $(`<input class="columnSearch" index="${index}" name="${name}" type="text" placeholder="Search col." style="max-width:5em"/>`);

        let val = qs[name] || '';
        input
          .val(val)
          .attr('title','Press enter to search')
          .appendTo($("thead tr:eq(0) > th").eq(index))
          .on("keydown", function() {
            if (!config["search"]["return"]) {
              that.search($(this).val()).draw('page');
            } else {
              let keycode = (event.keyCode ? event.keyCode : event.which);
              if (keycode == '13'){
                that.search($(this).val()).draw('page');
              }
            }
          });
          if (val) {
            input.css('background-color', 'yellow');
            input.attr('title','Remove text and press enter to clear search')
          }
        });
      console.log("Set search.")

    }

    async function getHeader() {
      let resp = await fetch(window.location.pathname + "header");
      const header = await resp.json();
      getHeader.header = header;
      return header;
    }

    async function getConfig() {

      const url = window.location.pathname + "config"
      console.log("getConfig() => Getting config from " + url)
      let resp = await fetch(url);
      const config = await resp.json();

      const tableName = $('title').text();
      config.tableName = tableName;
      if (!config['columns']) {
        config['columns'] = await getHeader();
      }
      // Update config['columns'] and config['colReorder']
      _columns(config);

      // Update config['pageLength'] and config['lengthMenu']
      _pageLength(config);

      config['ajax'] = window.location.pathname + "data/";
      config['serverSide'] = true;
      if (config['serverSide']) {
        config['ajax'] = {
          "url": window.location.pathname + "data/",
          "type": "get",
          "data": _ajaxData
        }
      }

      console.log("getConfig() => returning config:")
      console.log(config)

      return config;

      function _pageLength(config) {
        // Update pageLength and lengthMenu if needed.
        if (!config['pageLength']) {
          config['pageLength'] = 25;
          console.log("_pageLength() => No config['pageLength']. Setting default pageLength to 25");
          try {
            config['pageLength'] = config['lengthMenu'][0][0]
            console.log(`_pageLength() => config['lengthMenu'][0][0] found. Modifying default pageLength to be first entry in config['lengthMenu']: ${config['pageLength']}`);
          } catch(e) {
            console.log("_pageLength() => config['lengthMenu'][0][0] not found. Could not get modified default pageLength from config['lengthMenu']. Using 25.")
          }
        }
        let pageLength = config['pageLength'];
        if (getQueryValue('_length')) {
          console.log(`_pageLength() => _length query value found. Modifying default pageLength to be _length: ${getQueryValue('_length')}`);
          pageLength = parseInt(getQueryValue('_length'));
        }
        config['pageLength'] = pageLength;

        if (config['lengthMenu']) {
          try {
            console.log(`_pageLength() => Attempting to updated config['lengthMenu'] to include pageLength = ${pageLength}, if not already present.`);
            const menuVals = config['lengthMenu'][0];
            const menuNames = config['lengthMenu'][1];
            if (!menuVals.includes(pageLength)) {
              menuVals.push(pageLength);
              menuNames.push(pageLength);
              console.log(`_pageLength() => Updated config['lengthMenu'] to include pageLength = ${pageLength}`);
              config['lengthMenu'][0] = menuVals;
              config['lengthMenu'][1] = menuNames;
            } else {
              console.log(`_pageLength() => config['lengthMenu'] already includes pageLength = ${pageLength}. No change made to config['lengthMenu'].`);
            }
          } catch(e) {
            console.log(`_pageLength() => Problem with config['lengthMenu']. Setting it to [[${pageLength}, -1], [${pageLength}, 'All']].`);
            config['lengthMenu'] = [[pageLength, -1], [pageLength, "All"]];
          }
        } else {
          console.log(`_pageLength() => No config['lengthMenu']. Setting it to [[${pageLength}, -1], [${pageLength}, 'All']].`);
          config['lengthMenu'] = [[pageLength, -1], [pageLength, "All"]];
        }

        // Sort lengthMenu[0] and lengthMenu[1] by lengthMenu[0] values but keep
        // the correspondence between values and names.
        if (config['lengthMenu']) {
          console.log(`_pageLength() => Sorting config['lengthMenu'] by values in config['lengthMenu'][0].`);
          let vals = config['lengthMenu'][0];
          let names = config['lengthMenu'][1];
          // Create array of [val, name], sort by val, then split back
          let pairs = vals.map((v, i) => [v, names[i]]);
          pairs.sort((a, b) => a[0] - b[0]);
          config['lengthMenu'][0] = pairs.map(p => p[0]);
          config['lengthMenu'][1] = pairs.map(p => p[1]);

          // If -1 is in lengthMenu[0], put it at the end of the list.
          const minusOneIndex = vals.indexOf(-1);
          if (minusOneIndex !== -1 && minusOneIndex !== vals.length - 1) {
            // Remove -1 and its name
            const [minusOneVal] = vals.splice(minusOneIndex, 1);
            const [minusOneName] = names.splice(minusOneIndex, 1);
            // Push to end
            vals.push(minusOneVal);
            names.push(minusOneName);
          }
          config['lengthMenu'][0] = vals;
          config['lengthMenu'][1] = names;
        }
      }

      function _columns(config) {
        // Update config['columns'] if needed.
        let columns = config['columns'];
        if (!columns || columns.length === 0) {
          console.log("_columns() => no columns given. Returning empty array.")
          return [];
        }

        console.log("_columns() => creating columns array")

        let _cols = getQueryValue('_cols');
        console.log("_columns() => _cols from query string:", _cols)
        let allVisible = true;
        if (_cols) {
          allVisible = false;
          if (_cols.endsWith('...')) {
            console.log("_columns() => allVisible is true b/c _cols ends with ...");
            allVisible = true;
            _cols = _cols.slice(0, -3);
          } else {
            console.log("_columns() => allVisible is false b/c _cols given and does not end with ...");
          }
          _cols = _cols.split(',');
          console.log("_columns() => _cols after removing ...:")
          console.log(_cols)
        } else {
          _cols = [];
        }


        let renderColumnFunction = window.renderColumn ? window.renderColumn : null;
        for (let i = 0; i < columns.length; i++) {
          if (typeof columns[i] === "string") {
            columns[i] = {
              "data": columns[i],
              "name": columns[i],
              "title": columns[i],
              "targets": i
            }
          }
          if (!('data' in columns[i])) {
            columns[i]['data'] = `col${i+1}`;
          }
          if (!('name' in columns[i])) {
            columns[i]['name'] = `col${i+1}`;
          }
          if (!('name' in columns[i])) {
            columns[i]['title'] = `col${i+1}`;
          }
          if (!('targets' in columns[i])) {
            columns[i]['targets'] = i;
          }
          columns[i]['visible'] = false;
          if (allVisible || _cols.includes(columns[i]['name'])) {
            columns[i]['visible'] = true;
          }
          // ellipsis.js plug-in
          // config['columns'][i]['render'] = DataTable.render.ellipsis( 10 )
          if (renderColumnFunction) {
            const render = renderColumnFunction(columns[i].name, config)
            if (render) {
              config['columns'][i]['render'] = render
            }
          }
        }
        console.log("_columns() => Created columns array:")
        console.log(columns)

        // Put indices of _cols in query string at first part of order.
        // Must do this after above loop so that columns[i]['name'] exists.
        let columnNameMap = _columnNameMap(config);
        let order = [];
        for (let i = 0; i < _cols.length; i++) {
          order.push(columnNameMap[_cols[i]]);
        }
        for (let i = 0; i < columns.length; i++) {
          // colReorder config requires including all columns, so append to end.
          if (!order.includes(i)) {
            order.push(i);
          }
        }

        console.log("_columns() => Created config.colReorder.order array:")
        console.log(order);
        config.colReorder = {'order': order};
      }

      function _ajaxData(dtp) {
        console.log("config['ajax'] callback. Preparing query parameters for AJAX search using dtp object:");
        console.log(dtp);

        let qs = parseQueryString();
        for (const [key, val] of Object.entries(qs)) {
          if (!(key in dtp) && config.columnNames.includes(key)) {
            console.log(`  Adding ${key} = '${val}' from query string to dtp object.`);
            dtp[key] = val;
          }
        }

        if (dtp.search.value) {
          dtp._globalsearch = dtp.search.value;
        }

        _orders = [];
        for (let i = 0; i < dtp.order.length; i++) {
          let c = dtp.order[i].column;
          let name = dtp.columns[c]['name'];
          _orders.push(dtp.order[i]['dir'] == 'asc' ? name : '-' + name);
        }
        dtp._orders = _orders.join(",");


        dtp._length = dtp.length;
        delete dtp.length;

        dtp._start = dtp.start;
        delete dtp.start;

        dtp._draw = dtp.draw;
        delete dtp.draw;
        //delete dtp.columns;
        delete dtp.search;
        delete dtp.order;

        console.log("  returning updated dtp object:")
        console.log(dtp);

        return dtp;
      }

    }

    function setEvents(tableID, _emptyColumns) {

      console.log('setEvents() => Setting search.dt.')
      //$(tableID).off('search.dt');
      $(tableID).on('search.dt', function (event, b, c) {
        //updateQueryString('_page', null);
        setQueryStringFromSearch()
      });

      return

      $(tableID).on('stateSaveParams.dt', function (e, settings, data) {})

      console.log('setEvents() => Setting page.dt.')
      let pageChanged = false;
      $(tableID).on('page.dt', function () {
        console.log('setEvents() => page.dt triggered')
        const info = $(tableID).DataTable().page.info();
        $('#pageInfo').html('Showing page: ' + info.page + ' of ' + info.pages);
        updateQueryString('_page', info.page + 1);
        pageChanged = true;
        //alert('pageChanged set to true');
      });

      console.log('setEvents() => Setting length.dt.')
      $(tableID).on('length.dt', function (e, settings, len) {
        console.log('setEvents() => length.dt triggered')
        updateQueryString('_length', len);
      })

      console.log('setEvents() => Setting preDraw.dt.')
      $(tableID).on('preDraw.dt', function () {
        console.log('setEvents() => preDraw.dt triggered')
      })

      console.log('setEvents() => Setting draw.dt and triggering it.')
      const table_paginate = `${tableID}_paginate`;
      console.log("setEvents() => Initial empty columns:")
      console.log(_emptyColumns)
      $(tableID)
        .on('draw.dt', function () {

          console.log('setEvents() => draw.dt triggered.')
          let qs = parseQueryString();
          const numSearchKeys = Object.keys(qs).filter(k => !k.startsWith('_')).length;
          if (numSearchKeys > 0) {
            console.log(`setEvents() => There are ${numSearchKeys} search terms in the query string. Showing Clear button.`)
            $('#clearAllSearches').show();
          } else {
            console.log("setEvents() => There are no search terms in the query string. Hiding Clear button.")
            $('#clearAllSearches').hide();
          }

          // Hide paging if only one page.
          if ($(tableID).dataTable().api().page.info().pages === 1) {
            console.log("Hiding pagination b/c only one page.")
            $(table_paginate).hide();
          } else {
            console.log("Showing pagination b/c multiple pages.")
            $(table_paginate).show();
          }

          const info = $(tableID).DataTable().page.info();
          if (info.pages > 0) {
            const _page = getQueryValue("_page")
            console.log(`setEvents() => _page = ${_page}, info.pages = ${info.pages}`)
            if (_page) {
              if (parseInt(_page) > info.pages) {
                console.log(`setEvents() => _page = ${_page} > info.pages = ${info.pages}. Setting _page to ${info.pages} and drawing page ${info.pages-1}.`)
                updateQueryString('_page', info.pages);
                $(tableID).DataTable().page(info.pages-1).draw('page');
              }
            }
          }

          console.log("setEvents() => Calling adjustDOM()")
          adjustDOM(tableID);

          if (pageChanged && getQueryValue('_cols_show') === 'nonempty') {
            console.log("Page was changed and _cols_show=nonempty. Checking for change in empty columns.")
            pageChanged = false;
            _emptyColumnsNow = emptyColumns(tableID);
            if (_emptyColumns.length === _emptyColumnsNow.length) {
              console.log("Number of empty columns has not changed. Not updating column visibility.")
              return;
            }
            console.log("Number of empty columns has changed. Calling init().")
            _emptyColumns = _emptyColumnsNow;
            init()
          }
        })
        .trigger('draw.dt');
        // trigger() above needed for initial load.

      console.log("Setting click event for hideEmptyColumns checkbox.")
      $('#hideEmptyColumns').click(function() {
        const table = $(tableID).dataTable();
        if ($(this).is(':checked')) {
          console.log("#hideEmptyColumns clicked to checked.")
          updateQueryString('_cols_show', 'nonempty');
          //init(emptyColumns(tableID));
          init();
        } else {
          console.log("#hideEmptyColumns clicked to unchecked.")
          updateQueryString('_cols_show', null);
          init()
        }
      });
    }

    function adjustDOM(tableID) {

      console.log("adjustDOM() called.")
      const table_info = `${tableID}_info`;
      const table_length = `${tableID}_length`;
      const table_filter = `${tableID}_filter`;
      const table_paginate = `${tableID}_paginate`;

      let input = $(`${table_filter} input`).attr('placeholder','Global search')
      $(`${table_filter} label`).replaceWith(input[0]);
      $(`${table_info}`).insertAfter(table_filter);

      let numCols = $(tableID).DataTable().columns().nodes().length;
      let numColsVisible = $(tableID).DataTable().columns(':visible').nodes().length;
      let colInfo = ` and all ${numCols} columns`;
      if (numCols !== numColsVisible) {
        colInfo = ` and ${numColsVisible} of ${numCols} columns`;
      }

      const info = $(tableID).DataTable().page.info();
      //console.log(info)
      let txt = `Showing ${parseInt(info.start)+1}-${parseInt(info.end)} of ${info.recordsDisplay} rows`
      if (info.recordsDisplay === 0) {
        txt = `Showing 0 rows`
      }
      if (info.recordsTotal != info.recordsDisplay) {
        txt += ` (filtered from ${info.recordsTotal} total)`
      }
      txt += `${colInfo}.`
      $(table_info).text(txt);
      $(table_paginate).insertAfter(table_filter);

      let select = $(`${table_length} select`)
      select.appendTo(table_length)
      $(`${table_length} label`).text('Rows per page: ')
      $('#table1_length').appendTo('#controls');

      const prev = $(`${tableID}_previous`);
      prev.attr('title','Previous page');
      if (prev.length > 0) {
        const html = prev.html();
        if (html) {
          prev.html(html.replace('Previous','◀'));
        }
      }

      const next = $(`${tableID}_next`);
      next.attr('title','Next page');
      if (next.length > 0) {
        const html = next.html();
        if (html) {
          next.html(html.replace('Next','▶'));
        }
      }

      setTimeout(function() {

        console.log("Executing $(window).resize() to to trigger event that causes left column header width to match the width of the left column body.")
        $(window).resize()

        $('[aria-describedby=table1_info]').removeAttr('aria-hidden')
        // The above line is needed to prevent the following error (which results
        // in updates to search inputs not being read by code that steps through
        // columns search inputs):
        // Blocked aria-hidden on an element because its descendant retained focus.
        // The focus must not be hidden from assistive technology users. Avoid
        // using aria-hidden on a focused element or its ancestor. Consider using
        // the inert attribute instead, which will also prevent focus. For more
        // details, see the aria-hidden section of the WAI-ARIA specification at
        // https://w3c.github.io/aria/#aria-hidden.
        // Element with focus: <input.columnSearch>

      }, 0);

      console.log("adjustDOM() finished.")
    }

    function emptyColumns(tableID) {
      let data = $(tableID).DataTable().rows({ page: 'current' }).data().toArray();
      console.log("emptyColumns() called. Data for current page:")
      console.log(data)
      let columnEmptyBoolean = [];
      for (let r = 0; r < data.length; r++) {
        for (let c = 0; c < data[r].length; c++) {
          if (r == 0) {
            columnEmptyBoolean.push(true);
          }
          if (data[r][c] !== null && data[r][c] !== "") {
            columnEmptyBoolean[c] = false;
          }
        }
      }

      let columnEmptyIndices = []
      for (let c = 0; c < columnEmptyBoolean.length; c++) {
        if (columnEmptyBoolean[c]) {
          columnEmptyIndices.push(c);
        }
      }
      console.log("Computed columnEmpty index array:")
      console.log(columnEmptyIndices)
      return columnEmptyIndices;

    }

    function destroy(tableID) {
      console.log("destroy() called.")

      let tableWrapper = $(tableID + "_wrapper");
      if (tableWrapper.length > 0) {
        console.log(`Destroying table ${tableID}`)
        // https://datatables.net/forums/discussion/comment/190544/#Comment_190544
        $(tableID).off('page.dt');
        $(tableID).off('length.dt');
        $(tableID).off('preDraw.dt')
        $(tableID).off('draw.dt');
        $('#tableMetadata').empty();
        $('#table1_length').remove();
        $(tableID).DataTable().state.clear();
        $(tableID).DataTable().destroy();
        tableWrapper.remove();
        $(tableID).empty();
        $('#hideEmptyColumns').unbind();
        console.log(`Destroyed table ${tableID}`)
      }
    }

    function _columnNameMap(config, invert) {
      // Create a map from column name to index
      const columnNameMap = {};
      for (let i = 0; i < config.columns.length; i++) {
        columnNameMap[config.columns[i].name] = i;
      }
      if (!invert) {
        return columnNameMap;
      }
      let invertedColumnNameMap = {};
      for (const [key, value] of Object.entries(columnNameMap)) {
        invertedColumnNameMap[value] = key;
      }
      return invertedColumnNameMap;
    }

    function clearAllSearches(tableID) {
      let qs = parseQueryString();
      for (const key in qs) {
        if (!key.startsWith('_')) {
          delete qs[key];
        }
      }
      location.hash = decodeURIComponent($.param(qs));
      init();
    }

    function parseQueryString() {
      // http://paulgueller.com/2011/04/26/parse-the-querystring-with-jquery/
      var nvpair = {};
      var qs = window.location.hash.replace('#', '');
      if (qs.length === 0) {
        return {};
      }
      var pairs = qs.split('&');
      $.each(pairs, function(i, v){
        var pair = v.split('=');
        nvpair[pair[0]] = pair[1];
      });
      return nvpair;
    }

    function getQueryValue(name, defaultValue) {
      let qs = parseQueryString();
      if (!qs[name]) {
        return defaultValue;
      }
      return qs[name];
    }

    function checkQueryString(what) {
      console.log("checkQueryString() => Checking query string for invalid column names.");

      let config = getConfig.config;
      let qs = parseQueryString();
      console.log("checkQueryString() => Query string:")
      console.log(qs);
      if (what === 'keys') {
        console.log("checkQueryString() => what = 'keys'. Checking keys but not values in query string.");
        let alerted = false;
        for (const [key, val] of Object.entries(qs)) {
          if (key.startsWith('_')) {
            console.log(`  found state parameter '${key}' in query string. Leaving it.`);
            continue;
          }
          if (config.columnNames.includes(key)) {
            console.log(`checkQueryString() => Found valid key = '${key}' in query string.`);
          } else {
            console.log(`checkQueryString() => Found invalid key = '${key}' in query string. Removing it.`);
            if (alerted === false) {
              alerted = true;
              alert(`Invalid column name in query string: "${key}". Removing it from query string and any other invalid column names.`);
            }
            updateQueryString(key, null);
          }
        }
      }

      if ('what' === 'cols') {
        console.log("checkQueryString() => what = 'cols'. Checking only _cols parameter in query string.");
        let columnNames = getQueryValue('_cols');
        if (!columnNames) {
          console.log("checkQueryString() => No _cols in query string. Leaving it.")
          return;
        }
        let columnNameMap = _columnNameMap(config);
        columnNames = columnNames.split(',');
        let updateHash = false;
        for (let i = 0; i < columnNames.length; i++) {
          let colName = columnNames[i];
          if (colName in columnNameMap) {
            continue;
          } else if (colName === '...') {
            delete columnNames[colName];
          } else {
            console.log(`checkQueryString() => Column name '${colName}' not found in config.columnDefs.`);
            if (!updateHash) {
              alert(`checkQueryString() => Column name in query string not found: "${colName}". Removing it and any other invalid column names from query string.`);
            }
            updateHash = true;
            delete columnNames[i];
          }
        }
        if (updateHash) {
          console.log("checkQueryString() => Updating query string to remove invalid column names.")
          columnNames = columnNames.filter(Boolean); // Remove any null/undefined values
          console.log(columnNames)
          updateQueryString('_cols', columnNames.join(','));
        }
      }
    }

    function setQueryStringFromSearch() {
      console.log("setQueryStringFromSearch() called. Stepping through column search inputs.");

      // Step through column search inputs and update query string
      // Highlight inputs with search values and remove highlight for
      // inputs with no search value.

      const table = $("#table1").DataTable()
      const globalSearchValue = table.search();
      console.log('setQueryStringFromSearch() => Global Search Value: ' + globalSearchValue);

      const state = table.state()
      console.log('setQueryStringFromSearch() => columnControl from state:');
      console.log(state)

      let columns = state.columns
      let columnControl = state.columnControl
      console.log(`setQueryStringFromSearch() => Reading ${columns.length} column search inputs.`);
      for (let i = 0; i < columns.length; i++) {
        let name = columns[i].name;
        searchValue = columnControl[i].searchInput.value;
        if (searchValue) {
          console.log(`setQueryStringFromSearch() => Found search value for column '${name}'. Updating query string and highlighting input.`);
          //$(input).css('background-color', 'yellow');
          console.log(`Updating query string with search value for column '${name}' = '${searchValue}'.`);
          updateQueryString(name, searchValue);
        } else {
          console.log(`setQueryStringFromSearch() => No search value for column '${name}'.`);
          //$(input).css('background-color', '');
          let qs = parseQueryString();
          if (qs[name]) {
            console.log(`setQueryStringFromSearch() => Found ${name} in query string. Removing from query string.`);
            updateQueryString(name, null);
          }
        }
      }
    }

    function updateQueryString(name, val) {
      console.log(`updateQueryString() called with name='${name}' and val='${val}'`);
      let qs = parseQueryString();
      if (val === null) {
        console.log(`Removing ${name} from query string.`);
        delete qs[name];
      } else {
        qs[name] = val;
      }

      // Put _ parameters at end of query string
      const sortedKeys = Object.keys(qs).sort((a, b) => {
        if (a.startsWith('_')) return 1;
        return -1;
      });

      const sortedQs = {};
      for (const key of sortedKeys) {
        sortedQs[key] = qs[key];
      }
      location.hash = decodeURIComponent($.param(sortedQs));
    }

  </script>

</body>

</html>
